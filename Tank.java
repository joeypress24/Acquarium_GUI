import java.awt.geom.*;
import java.awt.*;
import javax.swing.*;
import javax.imageio.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import java.util.Random;

/**
The purpose of the Tank class is to house the main activities of the program-
the animals reside in the tank.
@author Press, Joey
*/
public class Tank extends JPanel implements Runnable {

  // an arraylist to hold all of the creatures
  private static ArrayList<SeaCreature> allCreatures = new ArrayList<SeaCreature>();

  // private BufferedImage fish_img;
  private BufferedImage back;
  private Graphics2D g2;
  private Random rand = new Random();
  private boolean isPaused = true;

  private Thread tankThread;
  protected int index;

  private SeaCreature selectedCreature;

/**
The Tank() constructor is responsible for building the Tank with all of the
necessary components and listeners.
*/
  public Tank() {
    super();

    // get new random spawn point for fish
    int tempX=rand.nextInt(500-100)+100;
    int tempY = rand.nextInt(500-100)+100;
    //create fish
    Fish fish = new Fish(tempX,tempY,1,1,1,1000);
    addMouseListener(fish);

    //get new random spawn point for shark
    tempX=rand.nextInt(350-250)+250;
    tempY=rand.nextInt(350-250)+250;
    // create shark
    Shark shark = new Shark(tempX,tempY,1,1,2,2000);
    addMouseListener(shark);

    // get new random spawn point for lionfish
    tempX = rand.nextInt(500-100)+100;
    tempY = rand.nextInt(500-100)+100;
    // create lionfish
    LionFish lion = new LionFish(350,350,1,2,1,5000);
    addMouseListener(lion);

    // add the initial animals in the tank to the overall list
    allCreatures.add(fish);
    allCreatures.add(shark);
    allCreatures.add(lion);

    // initialize the background image
    this.back = null;
    try {
      back = ImageIO.read(new File("fish_background.jpg"));
    }
    catch (IOException e) {
    }

    // create a new Thread!
    this.tankThread = new Thread(this);
    tankThread.start(); // start the thread (call run())
  }

/**
The paintComponent is responsible for paining the objects on each run through
the program.
@param g representing the graphics object that is generated by the parent class.
*/
  protected void paintComponent(Graphics g)
  {
    super.paintComponent(g);

    g.drawImage(back, 0, 0, null);

    // cast g into the better object
    Graphics2D g2 = (Graphics2D)g;

    // This voodoo makes the output prettier
    g2.setRenderingHint(
    RenderingHints.KEY_ANTIALIASING,
    RenderingHints.VALUE_ANTIALIAS_ON);
    g2.setRenderingHint(
    RenderingHints.KEY_RENDERING,
    RenderingHints.VALUE_RENDER_QUALITY);

    // draw the fish
    // going to have to be a for each loop
    for(SeaCreature f : allCreatures)
    {

      if(f.getXScale() < 0)
      {
      // offset the image to account for rectangle being outside flip
        g2.drawImage(f.getImage(), f.getThisX()+50, f.getThisY(), f.getXScale(), f.getYScale(), null);
      }
      else
      {
        g2.drawImage(f.getImage(), f.getThisX(), f.getThisY(), f.getXScale(), f.getYScale(), null);
      }
      if(f.getClickStatus())
        g2.draw(f); // draw the rectangle
    }

    Toolkit.getDefaultToolkit().sync();
  }

/**
The run() method happens when a new thread is created, and it is responsible for
continuously updating the program as it moves.
*/
  public void run()
  {
    try{
      Thread.sleep(200);
    }
    catch(Exception e)
    { }

    ArrayList<Integer> toRemove = new ArrayList<Integer>();
    index = 0;
    while(true)
    {
      for(SeaCreature f : allCreatures)
      {//loop through each
        if(!isPaused)
        {
          f.move(); // move each fish
        }

        // check intersection
        int killCreatureIndex = testIntersection(f);
        if(killCreatureIndex != -1)
          toRemove.add(killCreatureIndex);

        // check if dead, then remove from arraylist
        if(!f.alive())
        {
          toRemove.add(index);
        }

        index++;
      }
      index = 0;

      removeCreature(toRemove);

      // pause the program briefly to prevent speed moving
      try{
        Thread.sleep(10);
      }
      catch(Exception e)
      { }
      // repaint everything (outside of for each loop)
      repaint(); // calls paintcomponent for me
    }
  }

/**
The removeCreature method takes in an ArrayList of integers that represent the
indexes of objects that need to be removed from the tank.
@param toRemove representing the total list of animals to be removed.
*/
  public void removeCreature(ArrayList<Integer> toRemove)
  {
    for(Integer i : toRemove)
    {
      allCreatures.remove((int)i);
    }
    //empty the toRemove list
    toRemove.removeAll(toRemove);
  }

/**
intersects() is responsible for checking if two rectangles intersect, and
killing the lower priority creature if there is an intersection
@return int representing the index of the creature that needs to die, -1 if no
one dies.
@param r representing the SeaCreature that is being tested against the rest.
*/
  public int testIntersection(SeaCreature r)
  {
    int retVal = -1;
    int ind = 0;
    for(SeaCreature s : allCreatures)
    {
      if(r.intersects(s) && !s.getName().equals(r.getName()))
      {
        if(r.getPriority() < s.getPriority())
        {
          // set index to be removed
          retVal = ind;

          // add health to the eating creature
          r.addHealth();
        }
      }
      ind++;
    }
    return retVal;
  }

/**
addPlankton() is responsible for adding plankton to the tank.
*/
  public void addPlankton()
  { //for plankton we only care about X because they spawn at surface (y=0)
    int tempX=rand.nextInt(550-50)+50;
    Plankton plankton = new Plankton(tempX, 0, 1, 1);
    allCreatures.add(plankton);
  }

/**
addFish() is responsible for adding fish to the tank.
*/
  public void addFish()
  {
    // generate a new random coordinate set to spawn the fish
    int tempX=rand.nextInt(250-100)+100;
    int tempY = rand.nextInt(250-100)+100;
    Fish fish = new Fish(tempX,tempY,1,1,1,3000);
    addMouseListener(fish);
    allCreatures.add(fish);
  }

/**
addLionFish() is responsible for adding LionFish to the tank.
*/
  public void addLionFish()
  {
    int tempX=rand.nextInt(250-100)+100;
    int tempY = rand.nextInt(250-100)+100;
    System.out.println("tempx: " + tempX + " tempy: " + tempY);
    LionFish lion = new LionFish(tempX,tempY,1,2,1,5000);
    addMouseListener(lion);
    allCreatures.add(lion);
  }

/**
addShark() is responsible for adding shark to the tank.
*/
  public void addShark()
  {
    int tempX=rand.nextInt(350-250)+250;
    int tempY=rand.nextInt(350-250)+250;
    Shark shark = new Shark(tempX,tempY,1,1,2,3000);
    addMouseListener(shark);
    allCreatures.add(shark);
  }

/**
puaseUnpause() is responsible for flipping the boolean variable that dictates if
things are happening in the tank or not.
*/
  public void pauseUnpause()
  {
    this.isPaused = !this.isPaused;
  }

/**
setImmortal() loops through the creatures and calls the lower level functions
to make the desired animals immortal.
@param s representing the animal that needs to be immortal.
*/
  public void setImmortal(String s)
  {
    for(SeaCreature temp : allCreatures)
    {
      if(s.equals(temp.getName()))
      {
        temp.makeImmortal();
      }
    }
  }

/**
the addHealth() method is responsible for adding a user-indicated amount of
health to a specified animal.
@param s representing the object that needs health.
@param num representing the amount of health to be added.
*/
  public void addHealth(String s, int num)
  {
    for(SeaCreature temp : allCreatures)
    {
      if(s.equals(temp.getName()))
      {
        temp.addHealth(num);
      }
    }
  }

/**
setThreshold is reponsible for implementing advanced controls and allowing the
user to change the speed of the animals.
@param s representing the animal that is being changed.
@param num representing the new speed.
*/
  public void setThreshold(String s, int num)
  {
    for(SeaCreature temp : allCreatures)
    {
      if(s.equals(temp.getName()))
      {
        temp.resetStepCounter();
        temp.setThreshold(num);
      }
    }
  }

/**
isClicked returns true if an animal has been clicked and saves the creature that
has been selected.
@return boolean representing whether or not someone has been clicked on.
*/
  public boolean isClicked()
  {
    for(SeaCreature temp : allCreatures)
    {
      //System.out.println(temp.getClickStatus());
      if(temp.getClickStatus())
      {
        this.selectedCreature = temp;
        return true;
      }
    }
    return false;
  }

/**
getHealthFromSelected() gets the health of the selected creature.
@return int representing the health of the selected creature.
*/
  public int getHealthFromSelected()
  {
    return selectedCreature.getHealth();
  }

/**
getSpeedFromSelected() gets the speed of the selected creature.
@return int representing the speed of the selected creature.
*/
  public int getSpeedFromSelected()
  {
    return selectedCreature.getThreshold();
  }

/**
getPriorityFromSelected() gets the priority of the selected animal.
@return int representing the priority of the selected animal
*/
  public int getPriorityFromSelected()
  {
    return selectedCreature.getPriority();
  }

}
